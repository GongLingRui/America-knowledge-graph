https://www.youtube.com/watch?v=fJLCCmk0-ok&list=PLDhh0lALedc5paY4N3NRZ3j_ui9foL7Qc&index=3

【时间】00:08–03:50
【主题】两种主流知识图谱数据模型简介：RDF与属性图

【核心知识点】
• 两种主流知识图谱数据模型：Resource Description Framework (RDF，资源描述框架) 和 Property Graphs (属性图)。
• RDF的查询语言是 SPARQL (SPARQL Protocol and RDF Query Language)。
• Property Graphs的查询语言是 Cypher。
• 本节课程目标：提供初步概念，以便理解两种数据模型的比较，以及它们与传统关系型数据模型的关系。
• RDF最初设计用于在万维网（Web）上表示信息，以便于发布和发现数据。
• RDF由万维网联盟（W3C， Worldwide Web Consortium）大力推动和标准化。
• RDF的基本构成单元是三元组（Triple）：主体（Subject）、谓词（Predicate）、宾语（Object）。这与上节课定义的“知识图谱是一个有向标签图”完全对应。
• RDF数据模型包含三种节点类型：
    1. 国际化资源标识符（IRIs， Internationalized Resource Identifiers）
    2. 字面量（Literals）
    3. 空白节点（Blank Nodes）

【重要例子 / 实验】
1. RDF节点类型之IRI示例：
   - URL (Uniform Resource Locator)：`http://example.org/index.html` (包含访问协议)。
   - URI (Uniform Resource Identifier)：`example.org/index.html` (不一定指定访问方法)。
   - IRI：`example.org/Βικιπαίδεια` (可使用ASCII之外的全套通用字符集，如外语字符)。
2. RDF节点类型之字面量（Literals）示例：
   - `:bob :age 23.` （通常可推断23为整数类型）。
   - `:bob :age "23"^^xsd:integer.` （显式指定类型为XML模式定义中的整数）。
   - `:bob :age "23"^^xsd:int.` （另一种整数类型表示）。
3. RDF节点类型之空白节点（Blank Nodes）的用例：用于表示结构化信息。
   - 具体示例：编码地址信息，如“`... :address _:addr1.`”和“`_:addr1 :street "1501 Grant Avenue"; :city "Bedford"; :state "Massachusetts".`”。

【老师强调 / 警告 / 易错点】
⚠️ RDF中的谓词（Predicate）也需要使用IRI来表示，例如 `:knows`。
⚠️ IRI与URI的关键区别在于字符集：URI仅限于US-ASCII字符集，而IRI可使用通用字符集。
⚠️ 为了简化冗长的IRI，RDF提供了定义前缀（Prefix）的机制。例如，定义 `foaf:` 前缀指向 `http://xmlns.com/foaf/0.1/` 后，就可以用 `foaf:knows` 来代替完整的IRI。
⚠️ RDF中使用的标准类型（如`xsd:integer`）并非RDF自身定义，而是引用自XML Schema Definition (XSD)。使用`xsd:`命名空间来引用这些标准类型。
⚠️ 空白节点（Blank Nodes）没有全局标识符（IRI），因此在其被引入的上下文之外无法引用。
⚠️ 本节课程不是深入严谨的介绍，目标是提供足够的概览以进行比较和理解关联。

【其他细节 / 补充说明】
- 在“Art knows Bob”的RDF表示示例中，Art和Bob的IRI分别为 `http://example.org/art` 和 `http://example.org/bob`。
- 任何提供IRI的数据源都可能在被查询时提供关于该对象的额外细节和定义。
- 后续课程将讨论如何构造这些IRI。

【时间】09:31–19:55
【主题】RDF细节、SPARQL查询语言与属性图模型概述

【核心知识点】
• 空白节点（Blank Nodes）的具体用途：表示结构化信息，避免为整个复合对象（如地址）创建全局IRI。
• 空白节点的语法：以“`_:`”开头，例如“`_:art_address`”。
• 空白节点的限制：只能在定义它们的当前RDF文档（RDF document）上下文内使用，无法在外部引用。
• RDF词汇表（RDF Vocabulary）：由一组用于描述数据的IRI定义。
• RDF数据本质上是静态的（a static view of the world），但存在扩展（extensions in RDF vocabulary）用于捕获数据动态性（capture the dynamics of the data）。
• RDF数据集（RDF Data Set）：由一组RDF图（RDF graphs）构成。
• 每个RDF数据集有且只有一个默认图（Default Graph），以及零个或多个命名图（Named Graphs）。
• 命名图的名称可以是IRI或空白节点，也可以留空（left blank）。
• 命名图的用途：将数据集中的不同部分分组到多个可能不连通的图中。查询时，可指定针对某个特定命名图，若不指定，则针对默认图评估查询。
• SPARQL查询语言的名称全称：SPARQL Protocol and RDF Query Language (SPARQL协议与RDF查询语言)。
• SPARQL区别于其他查询语言的显著特征：可以跨多个数据源（across multiple sources）进行查询，这通过使用定义在不同数据源（网站）中的IRI实现。
• SPARQL是一个功能完整的查询语言（full-featured query language），支持必需参数（required parameters）、可选参数（optional parameters）、结果过滤（filter the results）。
• SPARQL查询结果可以是数据（data），也可以是图（graph）。
• SPARQL查询中的核心概念：图模式（Graph Pattern），即写在WHERE子句中的一组三元组模式，用于与RDF数据进行匹配。
• SPARQL查询中的变量（Variables）以“`?`”或“`$`”为前缀，例如“`?person`”。
• 在SPARQL查询中也可以使用前缀（Prefixes）来缩写IRI，使查询更紧凑。
• 使用`CONSTRUCT`子句的查询返回的结果是一个新的RDF图（RDF graph），而不是数据列表。
• SPARQL支持的功能：多个图模式（more than one graph pattern）、消除重复项（eliminate duplicates）、计数（count）、聚合操作（aggregate operations）。
• 属性图数据模型（Property Graph Data Model）被许多图数据库（graph databases）采用。
• 采用属性图模型的图数据库示例：Neo4j。
• Amazon Neptune本身不限定于属性图模型。
• 多个图数据库基于属性图模型构建。

【重要例子 / 实验】
1. 空白节点用例示例：
   - 问题：地址“1501 Grant Avenue, Bedford, Massachusetts”作为一个字符串字面量无法分离其组成部分（街道、城市、州）。
   - 解决方案：引入一个空白节点 `_:art_address`。
   - 实现：`... :address _:art_address. _:art_address :street "1501 Grant Avenue"; :city "Bedford"; :state "Massachusetts".`
2. SPARQL基础查询示例1（单变量单模式）：
   - 查询目标：找出Art认识的所有人。
   - 查询语句：`SELECT ?person WHERE { art foaf:knows ?person. }`
   - 图模式：`art foaf:knows ?person.`
   - 变量：`?person`
   - 数据示例（假设）：Art认识Bob和Babe。
   - 查询结果：返回两个绑定，`?person` 分别为Bob和Babe的IRI。
3. SPARQL基础查询示例2（双变量双模式，遍历两层）：
   - 查询目标：找出Art认识的人所认识的人。
   - 查询语句：`SELECT ?person ?person1 WHERE { art foaf:knows ?person. ?person foaf:knows ?person1. }`
   - 图模式：`art foaf:knows ?person.` 和 `?person foaf:knows ?person1.`
   - 查询结果：一个表格，包含 `?person` 和 `?person1` 两列。
4. SPARQL结果过滤示例1（基于正则表达式）：
   - 数据示例：图书数据，包含 `:title` 和 `:price`。
   - 查询目标：找出所有标题以“SPARQL”开头的书。
   - 查询语句：`SELECT ?book WHERE { ?book ex:title ?title. FILTER regex(?title, "^SPARQL") }`
   - 过滤条件：`FILTER regex(?title, "^SPARQL")` （正则表达式，`^`表示开头）。
5. SPARQL结果过滤示例2（基于数值约束）：
   - 查询目标：找出所有价格低于30的书。
   - 查询语句：`SELECT ?book WHERE { ?book ex:price ?price. FILTER (?price < 30) }`
   - 过滤条件：`FILTER (?price < 30)`。

【老师强调 / 警告 / 易错点】
⚠️ 空白节点（匿名对象）无法在其被引入的当前RDF文档上下文之外使用。
⚠️ 跨数据源查询（queries that go across multiple sources）是SPARQL的显著特征，其实现机制依赖于引用分布在不同数据源（网站）中的IRI。具体如何执行将在关于“分布式SPARQL查询执行（distributed SPARQL query execution）”的讲座（由Guest speaker Professor Kamer Kaya主讲）中详细讲解。
⚠️ 在SPARQL查询中使用前缀定义后，查询语句可以更紧凑，但查询结果会返回完整的IRI。
⚠️ SPARQL的`FILTER`子句支持使用正则表达式（regular expression）和数值比较进行结果过滤。
⚠️ 使用`CONSTRUCT`子句的查询返回的结果是一个RDF图，而不仅仅是数据列表。

【其他细节 / 补充说明】
- 有学生指出，匿名空白节点（anonymous blank nodes）在功能上类似于“scoped constants”（作用域内的常量），讲师表示同意。
- 讲师确认，关于跨数据源查询的“如何做（how）”细节将推迟到下周（周四）由客座教授Kamer Kaya讲解，主题是“分布式SPARQL查询执行”。



【时间】20:02–30:29
【主题】属性图数据模型、Cypher查询语言及其与RDF的初步比较

【核心知识点】
• 属性图数据模型（Property Graph Data Model）定位：适用于通用图数据，特别是模式自由（schema-free）的应用场景。
• 属性图数据模型的适用场景：图的遍历（traversing the graph）非常重要。
• 属性图数据模型的三个基本构造：
    1. 节点（Nodes）
    2. 关系（Relationships）
    3. 属性（Properties）
• 节点和关系都有标签（label）。
• 属性和节点/关系的关联：每个节点（Node）和每个关系（Relationship）都可以关联一组属性（a set of properties）。
• 属性的形式：键值对（key-value pairs），键（key）是字符串（strings），值（value）可以是任意数据类型（any data type）。
• 关系具有方向（direction），因此属性图是有向图（directed graph）。
• Cypher查询语言的定位：最初为查询图数据设计，现正被考虑采纳为ISO标准。
• Cypher与SPARQL的一大区别：Cypher不仅限于查询操作（query operations），还支持完整的CRUD操作（CRUD operations），包括创建（Create）、读取（Read）、更新（Update）、删除（Delete）。
• Cypher查询的基本结构：包含一个 `MATCH` 子句，并可以返回变量。
• Cypher使用ASCII表示法（ASCII notation）来表示图模式（graph pattern）：用括号 `()` 表示节点，用中括号 `[]` 和箭头 `->` 或 `<-` 表示有向关系和方向。
• 在Cypher的ASCII表示法中，可以在节点和关系的括号内指定对标签（label）和属性（properties）的约束。
• Cypher也支持在 `WHERE` 子句中引入过滤约束（filter constraints）。
• Cypher支持的功能：计数（counting）、分组（grouping）、聚合（aggregating）、取最小值/最大值（taking mins and maxs）等。
• 关于RDF/SPARQL与网站（websites）关系的澄清：虽然典型用例是查询Web资源，但在理论上，也可以在一个与Web完全断开连接的中央服务器（central server）上使用SPARQL查询RDF数据集。一个孤立的网站是Web的一个退化情况（degenerate case）。
• RDF规范（RDF specification）和RDFS规范（RDFS specification）定义了一些标准的命名空间（standard namespaces），任何合规的RDF引擎（compliant RDF engine）都会识别和遵循这些定义。

【重要例子 / 实验】
1. “Art knows Bob”在属性图中的表示：
   - 两个节点，标签均为 `Person`。
   - 两个节点通过一个有向关系连接，关系的标签为 `KNOWS`。
   - 节点的属性：
        - 左边节点（代表Art）：有一个属性 `name`，值为 `"Art"`。
        - 右边节点（代表Bay，由Bob改为Bay）：有两个属性 `name: "Bay"` 和 `age: 28`。
   - 关系（边）的属性：`KNOWS` 关系有一个属性 `since: 2005`。
2. 设计决策的思考（反例/备选方案）：
   - 提问：为什么 `lives_near` 被建模为属性，而不是将城市建模为节点并用边连接？
   - 备选方案：可以创建一个标签为 `City` 的节点，其属性 `name: "Seattle"`，然后从人员节点创建一条指向该城市节点的、标签为 `LIVES_NEAR` 的边。
   - 结论：这是一个关键的设计决策（main design decision），涉及什么应作为节点、边或属性。更详细的考虑将在下周的课程中专门讲解。
3. Cypher基础查询示例1（查找Art认识的人）：
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS]->(b:Person) RETURN b`
   - 图模式（ASCII表示法）：`(a:Person {name:'Art'})-[r:KNOWS]->(b:Person)`
   - 组成部分：`(a:Person {name:'Art'})` 是带标签和属性约束的起始节点；`-[r:KNOWS]->` 是带标签的有向关系；`(b:Person)` 是带标签的目标节点。
4. Cypher基础查询示例2（在关系上添加属性约束）：
   - 查询目标：查找Art自2010年以来认识的人。
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS {since:2010}]->(b:Person) RETURN b`
   - 关系约束：在关系的括号内直接指定属性 `{since:2010}`。
5. Cypher基础查询示例3（使用WHERE子句进行更复杂的过滤）：
   - 查询目标：查找Art在2010年及以前（包括早于2010年）认识的人。
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS]->(b:Person) WHERE r.since <= 2010 RETURN b`
   - 实现方式：在关系模式中引入变量 `r`，然后在 `WHERE` 子句中添加约束 `r.since <= 2010`。

【老师强调 / 警告 / 易错点】
⚠️ 在属性图设计中，决定将某个概念建模为节点、边还是属性，是一个核心的设计决策（main design decision），没有唯一正确答案，需要根据应用场景权衡。
⚠️ Cypher与SPARQL的一个重要区别是支持完整的CRUD操作，而本次课程仅聚焦于“读取（Read）”操作。
⚠️ RDF/SPARQL的典型用例与Web和网站域名（web domains）相关联，但技术上并不强制要求必须联网。可以在一个完全离线的中央服务器上使用SPARQL。
⚠️ 关于如何在不涉及网站域名的情况下引用对象（如使用特殊前缀），讲师指出RDF/RDFS规范定义了一些标准命名空间，并建议将更详细的分布式查询执行问题推迟到下次讲座（由客座教授Kamer Kaya主讲）讨论。
⚠️ 有学生提问：“SPARQL是否只能查询网站上的信息？”和“RDF中所有IRI都必须关联一个网络域名和HTTP访问方法吗？”，讲师进行了上述澄清。

【其他细节 / 补充说明】
- 讲师计划在下周（周二）用一整节课来讲解属性图数据模型的设计决策（如节点/边/属性的选择）。
- 讲师提到，下次讲座（周四）的焦点是分布式SPARQL查询执行（distributed SPARQL query execution），将由客座教授Kamer Kaya主讲。
- 在属性图示例中，讲师将人名从“Bob”临时改为了“Bay”以增加示例的差异性，但强调核心概念不变。




【时间】20:02–30:29
【主题】属性图数据模型、Cypher查询语言及其与RDF的初步比较

【核心知识点】
• 属性图数据模型（Property Graph Data Model）定位：适用于通用图数据，特别是模式自由（schema-free）的应用场景。
• 属性图数据模型的适用场景：图的遍历（traversing the graph）非常重要。
• 属性图数据模型的三个基本构造：
    1. 节点（Nodes）
    2. 关系（Relationships）
    3. 属性（Properties）
• 节点和关系都有标签（label）。
• 属性和节点/关系的关联：每个节点（Node）和每个关系（Relationship）都可以关联一组属性（a set of properties）。
• 属性的形式：键值对（key-value pairs），键（key）是字符串（strings），值（value）可以是任意数据类型（any data type）。
• 关系具有方向（direction），因此属性图是有向图（directed graph）。
• Cypher查询语言的定位：最初为查询图数据设计，现正被考虑采纳为ISO标准。
• Cypher与SPARQL的一大区别：Cypher不仅限于查询操作（query operations），还支持完整的CRUD操作（CRUD operations），包括创建（Create）、读取（Read）、更新（Update）、删除（Delete）。
• Cypher查询的基本结构：包含一个 `MATCH` 子句，并可以返回变量。
• Cypher使用ASCII表示法（ASCII notation）来表示图模式（graph pattern）：用括号 `()` 表示节点，用中括号 `[]` 和箭头 `->` 或 `<-` 表示有向关系和方向。
• 在Cypher的ASCII表示法中，可以在节点和关系的括号内指定对标签（label）和属性（properties）的约束。
• Cypher也支持在 `WHERE` 子句中引入过滤约束（filter constraints）。
• Cypher支持的功能：计数（counting）、分组（grouping）、聚合（aggregating）、取最小值/最大值（taking mins and maxs）等。
• 关于RDF/SPARQL与网站（websites）关系的澄清：虽然典型用例是查询Web资源，但在理论上，也可以在一个与Web完全断开连接的中央服务器（central server）上使用SPARQL查询RDF数据集。一个孤立的网站是Web的一个退化情况（degenerate case）。
• RDF规范（RDF specification）和RDFS规范（RDFS specification）定义了一些标准的命名空间（standard namespaces），任何合规的RDF引擎（compliant RDF engine）都会识别和遵循这些定义。

【重要例子 / 实验】
1. “Art knows Bob”在属性图中的表示：
   - 两个节点，标签均为 `Person`。
   - 两个节点通过一个有向关系连接，关系的标签为 `KNOWS`。
   - 节点的属性：
        - 左边节点（代表Art）：有一个属性 `name`，值为 `"Art"`。
        - 右边节点（代表Bay，由Bob改为Bay）：有两个属性 `name: "Bay"` 和 `age: 28`。
   - 关系（边）的属性：`KNOWS` 关系有一个属性 `since: 2005`。
2. 设计决策的思考（反例/备选方案）：
   - 提问：为什么 `lives_near` 被建模为属性，而不是将城市建模为节点并用边连接？
   - 备选方案：可以创建一个标签为 `City` 的节点，其属性 `name: "Seattle"`，然后从人员节点创建一条指向该城市节点的、标签为 `LIVES_NEAR` 的边。
   - 结论：这是一个关键的设计决策（main design decision），涉及什么应作为节点、边或属性。更详细的考虑将在下周的课程中专门讲解。
3. Cypher基础查询示例1（查找Art认识的人）：
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS]->(b:Person) RETURN b`
   - 图模式（ASCII表示法）：`(a:Person {name:'Art'})-[r:KNOWS]->(b:Person)`
   - 组成部分：`(a:Person {name:'Art'})` 是带标签和属性约束的起始节点；`-[r:KNOWS]->` 是带标签的有向关系；`(b:Person)` 是带标签的目标节点。
4. Cypher基础查询示例2（在关系上添加属性约束）：
   - 查询目标：查找Art自2010年以来认识的人。
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS {since:2010}]->(b:Person) RETURN b`
   - 关系约束：在关系的括号内直接指定属性 `{since:2010}`。
5. Cypher基础查询示例3（使用WHERE子句进行更复杂的过滤）：
   - 查询目标：查找Art在2010年及以前（包括早于2010年）认识的人。
   - 查询语句：`MATCH (a:Person {name:'Art'})-[r:KNOWS]->(b:Person) WHERE r.since <= 2010 RETURN b`
   - 实现方式：在关系模式中引入变量 `r`，然后在 `WHERE` 子句中添加约束 `r.since <= 2010`。

【老师强调 / 警告 / 易错点】
⚠️ 在属性图设计中，决定将某个概念建模为节点、边还是属性，是一个核心的设计决策（main design decision），没有唯一正确答案，需要根据应用场景权衡。
⚠️ Cypher与SPARQL的一个重要区别是支持完整的CRUD操作，而本次课程仅聚焦于“读取（Read）”操作。
⚠️ RDF/SPARQL的典型用例与Web和网站域名（web domains）相关联，但技术上并不强制要求必须联网。可以在一个完全离线的中央服务器上使用SPARQL。
⚠️ 关于如何在不涉及网站域名的情况下引用对象（如使用特殊前缀），讲师指出RDF/RDFS规范定义了一些标准命名空间，并建议将更详细的分布式查询执行问题推迟到下次讲座（由客座教授Kamer Kaya主讲）讨论。
⚠️ 有学生提问：“SPARQL是否只能查询网站上的信息？”和“RDF中所有IRI都必须关联一个网络域名和HTTP访问方法吗？”，讲师进行了上述澄清。

【其他细节 / 补充说明】
- 讲师计划在下周（周二）用一整节课来讲解属性图数据模型的设计决策（如节点/边/属性的选择）。
- 讲师提到，下次讲座（周四）的焦点是分布式SPARQL查询执行（distributed SPARQL query execution），将由客座教授Kamer Kaya主讲。
- 在属性图示例中，讲师将人名从“Bob”临时改为了“Bay”以增加示例的差异性，但强调核心概念不变。



【时间】30:36–39:52
【主题】RDF与属性图模型的深度比较及具体转换

【核心知识点】
• 在RDF与属性图模型比较时，本讲座的限定范围：仅比较最基础的图表示（basic graph representation），不考虑RDF家族的其他语言（如RDF Schema, ontology languages, rule languages）或属性图的扩展。
• RDF与属性图模型在基础层面的三大差异：
    1. 属性图模型支持边属性（edge properties），而RDF模型不支持。
    2. 属性图模型不要求所有事物都必须用IRI来引用，而SPARQL/RDF为Web设计，默认使用IRI。
    3. 当前属性图模型没有与RDF中空白节点（blank nodes）完全相同的概念。
• RDF为了应对边属性的需求，提供了具体化机制（Reification）。
• RDF具体化需要用到四个新的谓词（predicates）和一个新的类（class）：
    - 四个谓词：`rdf:type`, `rdf:subject`, `rdf:predicate`, `rdf:object`。
    - 一个新的类：`rdf:Statement`。
• RDF具体化的步骤：
    1. 为需要附加属性的原始三元组发明一个新的对象（Object）来表示这个三元组。
    2. 声明这个新对象的类型（type）为 `rdf:Statement`。
    3. 使用 `rdf:subject`, `rdf:predicate`, `rdf:object` 将新对象与原始三元组的三个组成部分关联起来。
    4. 现在，可以对这个新对象（代表原始三元组）添加任意数量的新属性（使用额外的谓词）。
• 使用RDF具体化的后果：表示变得更冗长（more verbose），需要更多的三元组来表达属性图模型用一个边属性就能表达的内容，但并非无法实现。
• 对于“同一三元组出现在两个不同数据集中，且各自有不同属性”的场景，解决方法探讨：
    - 即使原始三元组相同，其在不同数据集中的具体化对象（reification object）的标识符（identifier）必须不同（例如 `triple12345` 和 `triple12346`）。
    - 为了区分具体化对象来自哪个数据集，可以使用命名图（named graphs）机制。
    - 可能需要在具体化对象上添加额外的属性来记录其来源数据集。
• 从属性图模型转换到RDF模型的基本规则：
    1. 属性图中的节点属性（node property）可以转换为一个RDF三元组。
    2. 属性图中两个节点之间的边（edge）也可以转换为一个RDF三元组。

【重要例子 / 实验】
1. 边属性需求在RDF中的具体化案例：
   - 原始需求：记录“物品重量为2.4”这一测量是由某人完成的。
   - 属性图解法：在表示“重量”的边上直接添加一个 `measured_by` 属性。
   - RDF解法（无具体化）：无法直接在 `<item> <weight> 2.4` 这个三元组上附加属性。
   - RDF具体化步骤：
        a) 发明一个新对象 `triple12345`。
        b) 添加三元组 `triple12345 rdf:type rdf:Statement`。
        c) 添加三元组 `triple12345 rdf:subject <item>`。
        d) 添加三元组 `triple12345 rdf:predicate <weight>`。
        e) 添加三元组 `triple12345 rdf:object 2.4`。
        f) 现在可以添加属性：`triple12345 dc:creator ex:af85740`（假设 `dc:creator` 表示创建者）。
   - 结果：用6个三元组表达了属性图中1个边属性可表达的内容。
2. “同一三元组，不同数据集，不同属性”的复杂性讨论（反例/潜在问题）：
   - 设置：完全相同的三元组 `<A> <P> <B>` 出现在数据集1和数据集2中。
   - 需求：在数据集1中，该三元组有属性 `validSince: 2003`；在数据集2中，该三元组有属性 `validSince: 2004`。
   - 挑战：如何在RDF中区分这两个三元组实例并附加各自的属性？
   - 解决方案探讨：
        - 在数据集1中，使用具体化对象 `instance1`，其 `rdf:subject`, `rdf:predicate`, `rdf:object` 指向 `<A>`, `<P>`, `<B>`，并添加属性 `instance1 validSince 2003`。
        - 在数据集2中，使用不同的具体化对象 `instance2`，其 `rdf:subject`, `rdf:predicate`, `rdf:object` 同样指向 `<A>`, `<P>`, `<B>`，并添加属性 `instance2 validSince 2004`。
        - 为了记录 `instance1` 来自数据集1，`instance2` 来自数据集2，可能需要在 `instance1` 和 `instance2` 上附加另一个属性（如 `sourceDataset`），或使用命名图（named graphs）来封装每个数据集的具体化信息。

【老师强调 / 警告 / 易错点】
⚠️ 本次比较仅限于RDF和属性图最核心的图表示能力，不涉及它们各自的扩展生态（如RDF Schema、本体语言、规则语言），这可能会使比较结论不全面。
⚠️ RDF中缺少边属性是其模型的一个限制，但可以通过具体化（reification）来迂回实现，代价是表示冗长。
⚠️ 具体化机制（reification）并非RDF独有，也可以在属性图模型中实现，但对于边属性这个用例，属性图模型是更直接的原生支持。
⚠️ 当同一个三元组陈述在不同上下文中需要不同属性时（例如在不同数据集中），RDF具体化会变得复杂，需要为每个实例创建不同的具体化对象，并可能需要额外机制（如命名图或额外属性）来追踪来源。这是RDF建模中一个潜在的陷阱。
⚠️ 从属性图到RDF的转换在概念上是直接的，但反向转换（从RDF到属性图）如果涉及具体化三元组，则会非常复杂。

【其他细节 / 补充说明】
- 讲师承认，本次比较是简化的，并指出更全面的比较应包含RDF家族的整个语言栈（layer of more complicated languages）。
- 在讨论具体化对象如何关联其来源数据集时，讲师认为使用命名图（named graphs）是一种可能的方法，但也承认可能有更简单的方式，这是第一个想到的方案。
- 有学生深入追问了跨数据集三元组标识和属性附加的细节，暴露了RDF具体化在实际应用中的一个复杂性。



【时间】39:59–48:14
【主题】模型间转换、关系模型与图模型的初步比较

【核心知识点】
• 属性图模型到RDF模型的转换细节：
    - 基本转换：节点属性变成RDF三元组，边变成RDF三元组。
    - 边属性的转换：需要对这些边进行具体化（reification），从而产生额外的三元组。
    - 潜在难点：在原始属性图中可能没有IRI，因此在转换到RDF时需要为其生成IRI。
• RDF模型到属性图模型的转换方案：
    - 最简单的方案（Simple/Brain-dead Translation）：将每个RDF三元组的主语（Subject）和宾语（Object）都转换为属性图中的节点，谓词（Predicate）转换为边。
    - 更优方案（Better Translation）的规则：
        1. 只为RDF中是IRI或空白节点的节点创建新的属性图节点。
        2. 对于RDF中的字面量（Literals），不创建新节点，而是将其作为节点属性（node property）。
    - 更优方案的效果：产生的节点数量更少（slightly less number of nodes），更符合属性图模型的设计初衷。
    - 复杂情况处理：对于RDF中使用具体化（reification）建模的信息，需要在转换到属性图时进行反向工程（reverse engineer），将具体化结构转换为带有边属性（edge properties）的关系。
• RDF与属性图模型的对比总结：
    - RDF是一个更庞大、更丰富的语言家族（larger and richer family of languages）的一部分。
    - 主要差异（属性图视角）：
        1. 属性图模型直接支持边属性，RDF不支持但可通过具体化迂回实现。
        2. RDF模型与IRI绑定，属性图模型不一定。
        3. 属性图模型中没有对空白节点的显式处理或需求。
    - 模型间转换可行性：两者数据可以相互转换（interconverted）。
    - 转换难度比较：从属性图转换到RDF相对更容易（a little easier），从RDF转换到属性图更困难（a lot more work），因为需要反向处理具体化。
• 关系模型（Relational Model）与图模型（Graph Model）比较的出发点：不是评判优劣，而是刻画差异，理解各自适用的问题类型和权衡。
• 双方阵营的典型论点：
    - 图模型支持者观点：
        1. 图模型更容易理解（easier to understand）。
        2. 图查询更紧凑（more compact）且更快（faster）。
    - 关系模型支持者反驳观点：
        1. 关系模式（Relational schema）也能通过适当的工具（如实体关系模型ER Model或概念模型）进行可视化，并非关系系统的固有局限。
        2. 图查询也能被编译（compile）成关系查询，并运行得一样快。
• 通过具体例子对比查询的紧凑性：
    - 数据场景：存在三个规范化后的关系表——Employee（员工）、Department（部门）、EmpDept（员工-部门连接）。
    - 查询目标：找出在IT部门（ID为“ITD”）工作的所有员工。
    - 属性图建模：Employee节点和Department节点，通过“WORKS_IN”边连接。

【重要例子 / 实验】
1. SQL查询示例（查找IT部门员工）：
   - 表结构：
        - `Employee(id, name, ...)`
        - `Department(id, name, manager)`
        - `EmpDept(empId, deptId)`
   - SQL查询语句：
        ```sql
        SELECT e.name
        FROM Employee e
        JOIN EmpDept ed ON e.id = ed.empId
        JOIN Department d ON ed.deptId = d.id
        WHERE d.name = 'IT';
        ```
   - 查询结构：包含两个连接（JOIN），一个筛选（WHERE）。
2. Cypher查询示例（相同目标）：
   - 图模式：Employee节点 -[WORKS_IN]-> Department节点。
   - Cypher查询语句：
        ```cypher
        MATCH (e:Employee)-[:WORKS_IN]->(d:Department {id:'ITD'})
        RETURN e.name;
        ```
   - 查询结构：一个MATCH子句，模式中包含节点标签和属性约束。

【老师强调 / 警告 / 易错点】
⚠️ 将RDF三元组“简单粗暴”地转换为属性图节点和边，是对属性图数据模型的滥用（abuse），因为没有充分利用其特性（如将字面量作为属性）。
⚠️ RDF到属性图的转换，如果涉及反向工程具体化结构，细节并不简单，可能相当复杂，足以开设一整门课。
⚠️ 关系模型与图模型的比较是微妙的。讲师强调其目的不是证明孰优孰劣，而是帮助理解每种模型适合解决什么问题及其权衡。
⚠️ 在关系模型与图模型的辩论中，关于查询性能的论点（图查询更快 vs. 关系查询能被优化得一样快）需要具体分析，不能一概而论。
⚠️ 在给出的SQL和Cypher查询对比中，明确显示了Cypher版本在语法上更紧凑（clearly more compact），但这仅代表一种查询场景。

【其他细节 / 补充说明】
- 讲师假设关系数据库的设计是经过规范化的最佳设计（best design for this particular domain），避免将数据库设计优劣纳入讨论。
- 在RDF到属性图的转换中，讲师提到更优方案（不为字面量创建节点）只是第一步，对于处理RDF具体化信息，需要进一步的工作，并且概念上不难但实现可能复杂。
- 关系模型支持者认为，通过适当的工具（如ER模型）可以实现关系模式的可视化，从而削弱图模型“更易理解”的论点。



【时间】48:19–1:05:01
【主题】模型比较的复杂性、局限性及课程总结

【核心知识点】
• 图查询更紧凑的论点需谨慎对待：SQL可以通过更简洁的语法（如使用逗号分隔表并指定WHERE条件）写出接近Cypher长度的查询。
• 评估模型比较时需要确保使用双方的最优版本（best version），这是一个值得做的练习。
• 关系模型对属性图数据的表示方法：可以用两个关系表来存储属性图数据。
    - 表1：存储三元组，包含节点属性（node properties）和关系（relationships）。
    - 表2：存储四元组（four tuples），专门用于边属性（edge properties），因为边属性本质上是四元组（主语、谓语、宾语、属性键值对）。
• 混合架构（Hybrid Architecture）的存在：存在一些系统，允许用户用图查询语言（如Cypher）表达查询，然后通过翻译器（translator）将其转换为对底层关系数据库的SQL查询，并优化执行。这种架构适用于部分数据在关系库、部分在图数据库的场景。
• 图模型在可视化方面的潜在优势：在图系统中，可视化表示的模式（schema）与数据的实际存储格式（storage format）是一致的，而在关系模型中，可视化（如ER图）与实际存储的表结构存在脱节（disconnect）。
• 使用关系引擎作为图数据存储机制是一个持续的研究和工作主题（topic of ongoing work and ongoing research），双方都有成功的高性能系统。
• 关于性能的深度讨论：
    - 论点1（关系模型支持者）：如果将数据存储为三元组，专门为三元组优化的语言/系统（即图系统）在速度上通常优于（dominate）也处理宽表的关系数据库。
    - 论点2（关系模型支持者）：三元组存储不总是最优的。如果数据是宽表形式（如一个人的所有属性在一个表的一行中），关系引擎访问速度会远超三元组数据库。
    - 结论：性能取决于数据模型（it does depend on your data model）。在知识图谱（即三元组）存储场景下，关系方法并非最优。但同样的数据如果用其他方式（如宽表）存储，关系模型可能表现更好。
    - 共识：即使对于知识图谱表示，关系实现仍然是一个可行的（viable）、具有可比性（comparable）的替代方案。
• 图模型的局限性（Limitations of the graph model）：
    1. 非二元关系（Non-binary relationships）：例如“A在B和C之间”（between）这种三元关系，无法直接用二元边建模。
        - 解决方法：可以使用具体化（reification）技术，但不自然（not the most natural）。
    2. 以数值为主、对象间关系很少的数据：例如追踪一个国家多年的人口数据，主要是数值（values），将其建模为节点和边优势有限（questionable），更适合使用关系模型放在表中处理。
• 知识图谱的适用边界：存在一些场景，知识图谱并非解决问题的“甜蜜点”（sweet spot），不应强行将所有数据塞入知识图谱。
• 课程总结要点：
    - RDF/SPARQL的主要用例是在万维网上建模和查询数据。
    - 属性图/Cypher是通用图数据库的数据模型。
    - 两种模型间可以相互转换。
    - 图查询在某些场景下更紧凑，尤其是涉及对象间关系遍历的查询。
    - 专门为对象遍历设计的图引擎在这些查询上可能表现更好。
    - 图模型在图形可视化方面有优势，因其存储格式与可视化格式一致。
• 关于四元组（Quadruples）的说明：RDF确实有四元组概念，其第四个参数（context）用于追踪三元组来自哪个图（named graph）。
• 构建图模型（conceptual representation）的关键挑战（Key challenges）：如何决定哪些概念作为节点（nodes）、哪些作为属性（properties）、哪些作为边（edges），以及是否需要具体化。这是下周讲座的重点。

【重要例子 / 实验】
1. 更紧凑的SQL版本示例（对先前查询的优化）：
   - 原SQL（使用LEFT JOIN）：`SELECT e.name FROM Employee e JOIN EmpDept ed ON e.id = ed.empId JOIN Department d ON ed.deptId = d.id WHERE d.name = 'IT';`
   - 更紧凑的SQL版本（使用逗号连接）：
        ```sql
        SELECT e.name
        FROM Employee e, EmpDept ed, Department d
        WHERE e.id = ed.empId
          AND ed.deptId = d.id
          AND d.name = 'IT';
        ```
   - 效果：长度与Cypher版本相近，但右侧（Cypher）版本被认为更直观（more intuitive）。
2. 关系表存储属性图数据的方案：
   - 表 `Triples(subject, predicate, object)`：存储所有节点和边（关系）。
   - 表 `Quadruples(subject, predicate, object, key, value)`：存储所有边属性（edge properties）。
3. 图模型局限性的具体例子：
   - 非二元关系：“City A is between City B and City C.” 无法用一条简单的有向边表示。
   - 数值数据：中国2000年人口12.67亿，2001年12.76亿……更适合存储在 `CountryYearPopulation` 表中，而非创建“年份”节点和“人口”属性边。

【老师强调 / 警告 / 易错点】
⚠️ 在进行SQL与图查询的对比时，需要确保比较的是双方最优的查询写法，否则结论可能有失偏颇。
⚠️ 将图数据存入关系表（三元组表和四元组表）后，可以利用现有关系引擎处理，这削弱了“必须使用图数据库”的论点，特别是在已有大量遗留关系数据的场景下。
⚠️ 图模型在可视化方面的优势在于其存储与可视化格式的一致性，而关系模型在这两者间存在脱节。
⚠️ 关于“关系引擎作为图存储后端”的性能问题，目前仍是开放的研究问题（open question / a bit of a research question）。
⚠️ 图模型（尤其是基于三元组的模型）并非万能。对于非二元关系或主要是数值型、关系稀疏的数据，强行使用图模型可能不是最佳选择。
⚠️ 在设计知识图谱时，决定什么作为节点、边或属性是一个重大挑战，需要专门的讲座来讲解。

【其他细节 / 补充说明】
- 讲师承认，他选择的例子是为了教学清晰（pedagogical way），如果还有更简单的对比方式，值得继续探索。
- 有听众（可能是另一位教授）指出，使用四元组（quadruples）是另一种为边附加属性的可能方案，RDF中确实用四元组来追踪三元组的来源图。
- 下周课程将专注于图数据模型的设计，内容包括：如何设计能长期存活的图数据模型，以及如何在图数据模型上定义约束（constraints）以维护其长期完整性。将有两位受邀嘉宾进行讲解。



【时间】1:05:06–1:09:12
【主题】模型选择、课程预告与最终总结

【核心知识点】
• 图模型（三元组）适用范围的边界：三元组可以解决很多问题，但不能解决所有问题（can't do all the problems），不应盲目坚持使用图模型，其他工具可能更适合特定问题。
• 关于“RDF模型 vs. 属性图模型，谁会最终胜出？”的回应：模型的选择和存续主要由应用需求（application requirements）、业务需求（business needs）和用例（use cases）驱动。
• 模型选择的社会文化因素（Social/Cultural Factor）：项目团队的背景和偏好会强烈影响技术选型。
    - 具有语义网背景（semantic background）的团队会使用RDF模型。
    - 来自Neo4j及相关社区的团队会偏爱属性图模型。
• 学术视角的核心关注点：无论RDF还是属性图，其共享的数学结构——有向标签图（directed label graphs）——才是更重要的。这个数学表示将长期存在（is going to be around for a long time）。
• 下次课程（周四）预告：将深入讲解分布式查询执行和Cypher语言的深度内容。
    - 第一位嘉宾：Professor Kamer Kaya。主题：分布式SPARQL查询执行（Distributed SPARQL execution），将解答“当数据分布在多个源时如何执行SPARQL查询”的问题。
    - 第二位嘉宾：Dr. Petra Selmer。背景：参与OpenCypher项目。内容：提供Cypher查询语言更全面深入的概述，并讲解Cypher如何被用作图查询语言标准（standard for graph query languages）的输入。

【重要例子 / 实验】
1. 社会文化因素影响技术选型的案例：
   - 案例1：一个NSF开放知识网络（NSF Open Knowledge Network）项目，如果团队成员有语义网背景，他们将使用RDF模型。
   - 案例2：一个NSF开放知识网络项目，如果团队成员来自Neo4j社区，他们将使用Neo4j（属性图模型）。
2. 分布式SPARQL查询的“悬而未决”问题：在SPARQL设计中，查询可以跨多个数据源（go to multiple sources）是一个内置特性（built-in feature），但之前系列的讲座中没有人具体展示如何实现这一点。这促使讲师专门寻找该领域的专家（Professor Kamer Kaya）来讲解。

【老师强调 / 警告 / 易错点】
⚠️ 不应盲目地（blindsided）坚持使用图模型（三元组）解决所有问题，需认识到其局限性，并为不同问题选择合适的工具。
⚠️ 技术选型（RDF vs. Property Graph）不仅仅是技术优劣问题，还深受团队背景、社区文化和项目生态等社会性约束（socially created constraint）的影响。
⚠️ 从学术角度看，RDF和属性图底层共享的“有向标签图”数学结构比具体实现模型之争更重要，这个抽象概念具有长期价值。
⚠️ 分布式SPARQL查询执行（如何跨多数据源查询）是一个重要但之前未被深入讲解的实际问题，需要在专门讲座中探讨。

【其他细节 / 补充说明】
- 讲师透露，他去年在组织研讨会系列时就对“如何实现跨数据源的SPARQL查询”这个问题耿耿于怀（a nagging question），因为很多演讲者都未涉及。为此他付出了大量努力（made a lot of effort）寻找该领域的领军人物，最终联系到了Professor Kamer Kaya。
- 讲师承认，他在本次讲座中对Cypher语言只是浅尝辄止（only sort of pleased you with），更深入的内容将由Dr. Petra Selmer在下节课提供。












